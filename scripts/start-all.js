#!/usr/bin/env node

/**
 * Intelligent development server starter with port conflict resolution
 */

import { spawn } from "child_process";
import path from "path";
import { fileURLToPath } from "url";
import fs from "fs";
import net from "net";
import dotenv from "dotenv";

// ES module equivalent of __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config({ path: path.join(__dirname, "../.env.local") });

// Colors
const colors = {
  reset: "\x1b[0m",
  bright: "\x1b[1m",
  cyan: "\x1b[36m",
  magenta: "\x1b[35m",
  yellow: "\x1b[33m",
  green: "\x1b[32m",
  red: "\x1b[31m",
  blue: "\x1b[34m",
};

// Port checking utility
function checkPort(port) {
  return new Promise((resolve) => {
    const server = net.createServer();

    server.listen(port, () => {
      server.once("close", () => resolve(true));
      server.close();
    });

    server.on("error", () => resolve(false));
  });
}

// Find available port starting from preferred port
async function findAvailablePort(startPort, maxAttempts = 10) {
  for (let i = 0; i < maxAttempts; i++) {
    const port = startPort + i;
    if (await checkPort(port)) {
      return port;
    }
  }
  throw new Error(`No available port found starting from ${startPort}`);
}

// Get user input
function getUserInput(question) {
  return new Promise((resolve) => {
    process.stdin.resume();
    process.stdin.setEncoding("utf8");

    console.log(question);

    process.stdin.once("data", (data) => {
      process.stdin.pause();
      resolve(data.toString().trim());
    });
  });
}

// Update .env file with ports
function updateEnvFile(ports) {
  const envPath = path.join(__dirname, "../.env");
  const envContent = `# Vite Environment Variables
# Auto-generated by start-all script - ${new Date().toISOString()}

# Asset Server URL - uses same server as WebSocket (must start with VITE_ to be available in browser)
VITE_ASSET_SERVER_URL=http://localhost:${ports.websocket}

# WebSocket Server URL (must start with VITE_ to be available in browser)
VITE_WS_PORT=${ports.websocket}

# Development server ports
PORT=${ports.frontend}
WS_PORT=${ports.websocket}
`;

  fs.writeFileSync(envPath, envContent);
  console.log(
    `${colors.green}üìù Updated .env with selected ports${colors.reset}`
  );
}

class IntelligentStarter {
  constructor() {
    this.processes = [];
    this.isShuttingDown = false;
    this.defaultPorts = {
      frontend: 5173,
      websocket: 5000,
    };
  }

  async start() {
    console.log(
      `${colors.bright}üé≤ Starting Nexus VTT Development Servers${colors.reset}`
    );
    console.log(
      `${colors.cyan}üîç Checking port availability...${colors.reset}\n`
    );

    try {
      // Check default ports
      const portStatus = await this.checkDefaultPorts();

      if (portStatus.conflicts.length === 0) {
        console.log(
          `${colors.green}‚úÖ All default ports are available!${colors.reset}\n`
        );
        await this.startServices(this.defaultPorts);
        return;
      }

      // Handle port conflicts
      await this.handlePortConflicts(portStatus);
    } catch (error) {
      console.error(
        `${colors.red}‚ùå Failed to start services: ${error.message}${colors.reset}`
      );
      process.exit(1);
    }
  }

  async checkDefaultPorts() {
    const status = { available: [], conflicts: [] };

    for (const [service, port] of Object.entries(this.defaultPorts)) {
      const isAvailable = await checkPort(port);

      if (isAvailable) {
        status.available.push({ service, port });
        console.log(
          `${colors.green}‚úÖ Port ${port} (${service}) - Available${colors.reset}`
        );
      } else {
        status.conflicts.push({ service, port });
        console.log(
          `${colors.red}‚ùå Port ${port} (${service}) - In Use${colors.reset}`
        );
      }
    }

    return status;
  }

  async handlePortConflicts(portStatus) {
    console.log(
      `\n${colors.yellow}‚ö†Ô∏è  Port conflicts detected!${colors.reset}`
    );
    console.log(`\n${colors.bright}What would you like to do?${colors.reset}`);
    console.log(`${colors.cyan}1.${colors.reset} Auto-select available ports`);
    console.log(`${colors.cyan}2.${colors.reset} Manually specify ports`);
    console.log(`${colors.cyan}3.${colors.reset} Show what's using the ports`);
    console.log(`${colors.cyan}4.${colors.reset} Abort startup`);

    const choice = await getUserInput(
      `\n${colors.bright}Enter your choice (1-4):${colors.reset}`
    );

    switch (choice) {
      case "1":
        await this.autoSelectPorts();
        break;
      case "2":
        await this.manualPortSelection(portStatus);
        break;
      case "3":
        await this.showPortUsage(portStatus.conflicts);
        await this.handlePortConflicts(portStatus); // Show menu again
        break;
      case "4":
        console.log(
          `${colors.yellow}üõë Startup aborted by user${colors.reset}`
        );
        process.exit(0);
        break;
      default:
        console.log(
          `${colors.red}Invalid choice. Please enter 1-4.${colors.reset}`
        );
        await this.handlePortConflicts(portStatus);
    }
  }

  async autoSelectPorts() {
    console.log(
      `${colors.cyan}üîç Auto-selecting available ports...${colors.reset}\n`
    );

    const ports = {
      frontend: await findAvailablePort(this.defaultPorts.frontend),
      websocket: await findAvailablePort(this.defaultPorts.websocket),
    };

    console.log(`${colors.green}‚úÖ Selected ports:${colors.reset}`);
    console.log(`   Frontend:  ${ports.frontend}`);
    console.log(`   Backend:   ${ports.websocket} (WebSocket + Assets)\n`);

    await this.startServices(ports);
  }

  async manualPortSelection(portStatus) {
    console.log(`${colors.cyan}üìù Manual port selection:${colors.reset}\n`);

    const ports = { ...this.defaultPorts };

    for (const conflict of portStatus.conflicts) {
      const newPort = await getUserInput(
        `${colors.bright}Enter new port for ${conflict.service} (currently ${conflict.port}):${colors.reset}`
      );

      const portNum = parseInt(newPort);
      if (isNaN(portNum) || portNum < 1024 || portNum > 65535) {
        console.log(
          `${colors.red}Invalid port number. Using auto-selected port.${colors.reset}`
        );
        ports[conflict.service] = await findAvailablePort(conflict.port);
      } else if (!(await checkPort(portNum))) {
        console.log(
          `${colors.red}Port ${portNum} is also in use. Using auto-selected port.${colors.reset}`
        );
        ports[conflict.service] = await findAvailablePort(portNum);
      } else {
        ports[conflict.service] = portNum;
      }
    }

    console.log(`${colors.green}‚úÖ Final port selection:${colors.reset}`);
    console.log(`   Frontend:  ${ports.frontend}`);
    console.log(`   Backend:   ${ports.websocket} (WebSocket + Assets)\n`);

    await this.startServices(ports);
  }

  async showPortUsage(conflicts) {
    console.log(
      `${colors.cyan}üîç Checking what's using the ports...${colors.reset}\n`
    );

    for (const conflict of conflicts) {
      console.log(
        `${colors.yellow}Port ${conflict.port} (${conflict.service}):${colors.reset}`
      );

      try {
        const { exec } = await import("child_process");
        const { promisify } = await import("util");
        const execAsync = promisify(exec);

        const result = await execAsync(`lsof -i :${conflict.port}`);
        console.log(result.stdout);
      } catch (error) {
        console.log(`   Unable to determine what's using this port`);
      }
      console.log("");
    }

    console.log(`${colors.cyan}üí° To free up ports, you can:${colors.reset}`);
    console.log(`   ‚Ä¢ Stop the conflicting processes`);
    console.log(
      `   ‚Ä¢ Use: ${colors.bright}lsof -ti:PORT | xargs kill -9${colors.reset}`
    );
    console.log("");
  }

  async startServices(ports) {
    // Update .env file
    updateEnvFile(ports);

    const services = [
      {
        name: "Backend Server",
        command: "npm",
        args: ["run", "server:dev"],
        cwd: path.join(__dirname, ".."),
        prefix: "üîå [BACKEND]",
        color: colors.magenta,
        env: { 
          PORT: ports.websocket.toString(),
          DATABASE_URL: process.env.DATABASE_URL
        },
      },
      {
        name: "Frontend",
        command: "npm",
        args: ["run", "dev"],
        cwd: path.join(__dirname, ".."),
        prefix: "üñ•Ô∏è  [FRONTEND]",
        color: colors.cyan,
        env: { PORT: ports.frontend.toString() },
      },
    ];

    // Setup graceful shutdown
    this.setupGracefulShutdown();

    // Start services
    console.log(`${colors.bright}üöÄ Starting all services...${colors.reset}\n`);

    for (const service of services) {
      this.startService(service);
      await new Promise((resolve) => setTimeout(resolve, 1000)); // Stagger startup
    }

    // Show success message
    setTimeout(() => {
      console.log(
        `\n${colors.bright}‚úÖ All services started successfully!${colors.reset}`
      );
      console.log(`üåê Frontend: http://localhost:${ports.frontend}`);
      console.log(`üîå Backend:  http://localhost:${ports.websocket} (WebSocket + Assets)`);
      console.log(
        `\n${colors.bright}üìù Press Ctrl+C to stop all services${colors.reset}\n`
      );
    }, 3000);
  }

  startService(service) {
    console.log(
      `${service.color}üöÄ Starting ${service.name}...${colors.reset}`
    );

    const childProcess = spawn(service.command, service.args, {
      cwd: service.cwd,
      stdio: ["pipe", "pipe", "pipe"],
      env: {
        ...process.env,
        ...service.env,
        FORCE_COLOR: "1",
      },
    });

    this.processes.push({ ...service, process: childProcess });

    // Handle stdout
    childProcess.stdout.on("data", (data) => {
      const lines = data
        .toString()
        .split("\n")
        .filter((line) => line.trim());
      lines.forEach((line) => {
        console.log(`${service.color}${service.prefix}${colors.reset} ${line}`);
      });
    });

    // Handle stderr
    childProcess.stderr.on("data", (data) => {
      const lines = data
        .toString()
        .split("\n")
        .filter((line) => line.trim());
      lines.forEach((line) => {
        console.log(`${service.color}${service.prefix}${colors.reset} ${line}`);
      });
    });

    // Handle process exit
    childProcess.on("close", (code) => {
      if (!this.isShuttingDown && code !== 0) {
        console.log(
          `${colors.red}${service.prefix} Process crashed with code ${code}${colors.reset}`
        );
        this.shutdown();
      }
    });

    childProcess.on("error", (error) => {
      console.log(
        `${colors.red}${service.prefix} Error: ${error.message}${colors.reset}`
      );
      this.shutdown();
    });
  }

  setupGracefulShutdown() {
    const shutdown = () => {
      this.shutdown();
    };

    process.on("SIGINT", shutdown);
    process.on("SIGTERM", shutdown);
  }

  shutdown() {
    if (this.isShuttingDown) return;
    this.isShuttingDown = true;

    console.log(
      `\n${colors.bright}üõë Shutting down all services...${colors.reset}`
    );

    this.processes.forEach(({ name, process, color }) => {
      console.log(`   ${color}Stopping ${name}...${colors.reset}`);
      process.kill("SIGTERM");
    });

    setTimeout(() => {
      process.exit(0);
    }, 3000);
  }
}

// Start the intelligent starter
const starter = new IntelligentStarter();
starter.start();
