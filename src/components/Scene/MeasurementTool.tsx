import React, { useCallback, useState, useEffect } from 'react';\nimport { dndUtils, type Point, type Measurement } from '@/types/drawing';\nimport type { Camera } from '@/types/game';\n\ninterface MeasurementToolProps {\n  isActive: boolean;\n  camera: Camera;\n  gridSize: number;\n  onMeasurement: (measurement: Measurement) => void;\n  svgRef: React.RefObject<SVGSVGElement>;\n}\n\nexport const MeasurementTool: React.FC<MeasurementToolProps> = ({\n  isActive,\n  camera,\n  gridSize,\n  onMeasurement,\n  svgRef\n}) => {\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [startPoint, setStartPoint] = useState<Point | null>(null);\n  const [currentPoint, setCurrentPoint] = useState<Point | null>(null);\n  const [measurements, setMeasurements] = useState<Measurement[]>([]);\n\n  // Convert screen coordinates to scene coordinates\n  const screenToScene = useCallback((screenX: number, screenY: number): Point => {\n    if (!svgRef.current) return { x: 0, y: 0 };\n    \n    const rect = svgRef.current.getBoundingClientRect();\n    const svgX = screenX - rect.left;\n    const svgY = screenY - rect.top;\n    \n    // Account for camera transform\n    const sceneX = (svgX - rect.width / 2) / camera.zoom + camera.x;\n    const sceneY = (svgY - rect.height / 2) / camera.zoom + camera.y;\n    \n    return { x: sceneX, y: sceneY };\n  }, [camera, svgRef]);\n\n  // Handle mouse events for measurement\n  const handleMouseDown = useCallback((e: React.MouseEvent) => {\n    if (!isActive || e.button !== 0) return;\n    \n    const point = screenToScene(e.clientX, e.clientY);\n    setStartPoint(point);\n    setCurrentPoint(point);\n    setIsDrawing(true);\n    e.stopPropagation();\n  }, [isActive, screenToScene]);\n\n  const handleMouseMove = useCallback((e: React.MouseEvent) => {\n    if (!isDrawing || !startPoint) return;\n    \n    const point = screenToScene(e.clientX, e.clientY);\n    setCurrentPoint(point);\n    e.stopPropagation();\n  }, [isDrawing, startPoint, screenToScene]);\n\n  const handleMouseUp = useCallback((e: React.MouseEvent) => {\n    if (!isDrawing || !startPoint) return;\n    \n    const endPoint = screenToScene(e.clientX, e.clientY);\n    \n    // Calculate distance using D&D 5e diagonal rules\n    const deltaX = endPoint.x - startPoint.x;\n    const deltaY = endPoint.y - startPoint.y;\n    const feetDistance = dndUtils.calculateDiagonalDistance(deltaX, deltaY, gridSize);\n    const gridDistance = Math.round(feetDistance / 5);\n    \n    // Create measurement\n    const measurement: Measurement = {\n      id: `measurement-${Date.now()}`,\n      start: startPoint,\n      end: endPoint,\n      distance: feetDistance,\n      gridDistance,\n      createdAt: Date.now(),\n      createdBy: 'current-user',\n      temporary: true,\n    };\n    \n    // Add to measurements and notify parent\n    setMeasurements(prev => [...prev, measurement]);\n    onMeasurement(measurement);\n    \n    // Reset drawing state\n    setIsDrawing(false);\n    setStartPoint(null);\n    setCurrentPoint(null);\n    \n    // Auto-remove temporary measurements after 5 seconds\n    setTimeout(() => {\n      setMeasurements(prev => prev.filter(m => m.id !== measurement.id));\n    }, 5000);\n    \n    e.stopPropagation();\n  }, [isDrawing, startPoint, screenToScene, gridSize, onMeasurement]);\n\n  // Clear measurements when tool becomes inactive\n  useEffect(() => {\n    if (!isActive) {\n      setIsDrawing(false);\n      setStartPoint(null);\n      setCurrentPoint(null);\n      setMeasurements(prev => prev.filter(m => !m.temporary));\n    }\n  }, [isActive]);\n\n  // Calculate current measurement while drawing\n  const getCurrentMeasurement = useCallback(() => {\n    if (!startPoint || !currentPoint) return null;\n    \n    const deltaX = currentPoint.x - startPoint.x;\n    const deltaY = currentPoint.y - startPoint.y;\n    const feetDistance = dndUtils.calculateDiagonalDistance(deltaX, deltaY, gridSize);\n    const gridDistance = Math.round(feetDistance / 5);\n    \n    return { feetDistance, gridDistance };\n  }, [startPoint, currentPoint, gridSize]);\n\n  const currentMeasurement = getCurrentMeasurement();\n\n  // Render measurement overlays\n  const renderMeasurement = (measurement: Measurement, isCurrent = false) => {\n    const midPoint = {\n      x: (measurement.start.x + measurement.end.x) / 2,\n      y: (measurement.start.y + measurement.end.y) / 2\n    };\n\n    return (\n      <g key={measurement.id} className={`measurement ${isCurrent ? 'current' : 'completed'}`}>\n        {/* Measurement line */}\n        <line\n          x1={measurement.start.x}\n          y1={measurement.start.y}\n          x2={measurement.end.x}\n          y2={measurement.end.y}\n          stroke={isCurrent ? '#00ff00' : '#ffff00'}\n          strokeWidth={2 / camera.zoom}\n          strokeDasharray={isCurrent ? '5,3' : 'none'}\n          markerEnd=\"url(#measurement-arrow)\"\n        />\n        \n        {/* Start point */}\n        <circle\n          cx={measurement.start.x}\n          cy={measurement.start.y}\n          r={4 / camera.zoom}\n          fill={isCurrent ? '#00ff00' : '#ffff00'}\n          stroke=\"#000000\"\n          strokeWidth={1 / camera.zoom}\n        />\n        \n        {/* End point */}\n        <circle\n          cx={measurement.end.x}\n          cy={measurement.end.y}\n          r={4 / camera.zoom}\n          fill={isCurrent ? '#00ff00' : '#ffff00'}\n          stroke=\"#000000\"\n          strokeWidth={1 / camera.zoom}\n        />\n        \n        {/* Distance label */}\n        <g transform={`translate(${midPoint.x}, ${midPoint.y})`}>\n          <rect\n            x={-30 / camera.zoom}\n            y={-12 / camera.zoom}\n            width={60 / camera.zoom}\n            height={24 / camera.zoom}\n            fill=\"rgba(0, 0, 0, 0.8)\"\n            rx={4 / camera.zoom}\n          />\n          <text\n            x={0}\n            y={4 / camera.zoom}\n            textAnchor=\"middle\"\n            fill=\"white\"\n            fontSize={12 / camera.zoom}\n            fontFamily=\"Arial, sans-serif\"\n          >\n            {measurement.distance}'\n          </text>\n          <text\n            x={0}\n            y={-8 / camera.zoom}\n            textAnchor=\"middle\"\n            fill=\"#cccccc\"\n            fontSize={10 / camera.zoom}\n            fontFamily=\"Arial, sans-serif\"\n          >\n            {measurement.gridDistance} sq\n          </text>\n        </g>\n      </g>\n    );\n  };\n\n  if (!isActive) return null;\n\n  return (\n    <g className=\"measurement-tool\">\n      <defs>\n        <marker\n          id=\"measurement-arrow\"\n          viewBox=\"0 0 10 10\"\n          refX=\"9\"\n          refY=\"3\"\n          markerUnits=\"strokeWidth\"\n          markerWidth=\"4\"\n          markerHeight=\"3\"\n          orient=\"auto\"\n        >\n          <path d=\"M0,0 L0,6 L9,3 z\" fill=\"#ffff00\" />\n        </marker>\n      </defs>\n      \n      {measurements.map(measurement => renderMeasurement(measurement))}\n      \n      {isDrawing && startPoint && currentPoint && currentMeasurement && renderMeasurement({\n        id: 'current',\n        start: startPoint,\n        end: currentPoint,\n        distance: currentMeasurement.feetDistance,\n        gridDistance: currentMeasurement.gridDistance,\n        createdAt: Date.now(),\n        createdBy: 'current-user',\n        temporary: true,\n      }, true)}\n      \n      <rect\n        x={-10000}\n        y={-10000}\n        width={20000}\n        height={20000}\n        fill=\"transparent\"\n        style={{ cursor: isActive ? 'crosshair' : 'default' }}\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n      />\n      \n      {isActive && !isDrawing && (\n        <g className=\"measurement-instructions\">\n          <text\n            x={10}\n            y={30}\n            fill=\"white\"\n            fontSize={14}\n            fontFamily=\"Arial, sans-serif\"\n          >\n            📏 Click and drag to measure distance\n          </text>\n          <text\n            x={10}\n            y={50}\n            fill=\"#cccccc\"\n            fontSize={12}\n            fontFamily=\"Arial, sans-serif\"\n          >\n            Uses D&D 5e diagonal movement rules\n          </text>\n        </g>\n      )}\n    </g>\n  );\n};\n\nexport const useMeasurements = () => {\n  const [measurements, setMeasurements] = useState<Measurement[]>([]);\n  \n  const addMeasurement = useCallback((measurement: Measurement) => {\n    setMeasurements(prev => [...prev, measurement]);\n    console.log(`📏 Measured: ${measurement.distance} feet (${measurement.gridDistance} squares)`);\n  }, []);\n  \n  const clearMeasurements = useCallback(() => {\n    setMeasurements([]);\n  }, []);\n  \n  const removeMeasurement = useCallback((id: string) => {\n    setMeasurements(prev => prev.filter(m => m.id !== id));\n  }, []);\n  \n  return {\n    measurements,\n    addMeasurement,\n    clearMeasurements,\n    removeMeasurement,\n  };\n};\n